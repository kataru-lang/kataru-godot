use kataru::*;
use std::fs;

/// Using the already loaded story, generate constants;
pub fn try_codegen_consts(path: &str, story: &Story) -> Result<()> {
    let source = build_codegen_consts(story)?;
    match fs::read_to_string(path) {
        Ok(old_source) => {
            if source == old_source {
                return Ok(());
            }
        }
        Err(_) => (),
    };
    if let Err(err) = fs::write(path, &source) {
        return Err(error!(
            "Error writing generated file to '{}': {}",
            path, err
        ));
    }
    Ok(())
}

/// Convert a kataru identifier to a Godot varname.
fn get_varname(name: &str) -> String {
    if name == "global" {
        "Global".to_string()
    } else {
        name.replace(":", "_")
    }
}

/// Simultaneously construct vectors of varnames and string.
fn get_vars<S: AsRef<str>>(names: &[S]) -> (Vec<String>, Vec<String>) {
    let mut defs = Vec::with_capacity(names.len());
    let mut varnames = Vec::with_capacity(names.len());

    for name in names {
        if name.as_ref().is_empty() {
            continue;
        }
        let varname = get_varname(name.as_ref());
        defs.push(format!("const {} = \"{}\"", varname, name.as_ref()));
        varnames.push(varname);
    }

    (varnames, defs)
}

/// Generates the code for
/// Make public for test access.
pub fn build_codegen_consts(story: &Story) -> Result<String> {
    // Collect all entities that need constants.
    let mut namespaces = Vec::<&str>::with_capacity(story.sections.len());
    let mut passages = Vec::<String>::with_capacity(story.sections.len());
    let mut characters = Vec::<String>::with_capacity(story.sections.len());

    // Keep track of namespace boundaries for passages and characters.
    // The last passage index used for this namespace`passage_bounds[namespace_enum]`.

    for (namespace, section) in &story.sections {
        // For global namespace, don't add global to the sorted list.
        // And don't prepend the namespace.
        if namespace == kataru::GLOBAL {
            for (character, _character_data) in &section.config.characters {
                characters.push(character.to_string());
            }
            for (passage_name, _passage) in &section.passages {
                passages.push(passage_name.to_string());
            }
        } else {
            namespaces.push(namespace);
            for (character, _character_data) in &section.config.characters {
                characters.push(format!("{}:{}", namespace, character));
            }
            for (passage_name, _passage) in &section.passages {
                passages.push(format!("{}:{}", namespace, passage_name));
            }
        }
    }

    // namespaces.sort();
    // passages.sort();
    characters.sort();

    // let (namespace_vars, namespace_defs) = get_vars_defs(&namespaces);
    // let (passage_vars, passage_defs) = get_vars_defs(&passages);
    let (character_vars, character_defs) = get_vars(&characters);

    let def_separator = "\n";
    let list_separator = ",\n    ";
    let source = format!(
        r###"# DO NOT EDIT.
# This file was autogenerated by Kataru based on your story.
{character_defs}

const NAMES: Array[String] = [
    {character_vars}
]

# Returns the character property for usage in the editor.
static func property(property_name: String) -> Dictionary:
	return {{
		"name": property_name,
		"type": TYPE_STRING,
		"usage": PROPERTY_USAGE_DEFAULT,
		"hint": PROPERTY_HINT_ENUM,
		"hint_string": ",".join(NAMES)
	}}
"###,
        // namespace_defs = namespace_defs.join(separator),
        // namespace_vars = namespace_vars.join(separator),
        // passage_defs = passage_defs.join(separator),
        // passage_vars = passage_vars.join(separator),
        character_defs = character_defs.join(def_separator),
        character_vars = character_vars.join(list_separator),
    );

    Ok(source)
}
