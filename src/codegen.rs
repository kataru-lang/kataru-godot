use kataru::*;
use std::{fs, path::PathBuf};

struct StoryConsts {
    namespaces: Vec<String>,
    passages: Vec<String>,
    characters: Vec<String>,
    commands: Map<String, Option<Params>>,
}
impl StoryConsts {
    /// Generates the code for
    /// Make public for test access.
    pub fn new(story: &Story) -> Self {
        // Collect all entities that need constants.
        let mut namespaces = Vec::<String>::with_capacity(story.sections.len());
        let mut passages = Vec::<String>::with_capacity(story.sections.len());
        let mut characters = Vec::<String>::with_capacity(story.sections.len());
        let mut commands = Map::<String, Option<Params>>::with_capacity(story.sections.len());

        // Keep track of namespace boundaries for passages and characters.
        // The last passage index used for this namespace`passage_bounds[namespace_enum]`.
        for (namespace, section) in &story.sections {
            // For global namespace, don't add global to the sorted list.
            // And don't prepend the namespace.
            if namespace == kataru::GLOBAL {
                namespaces.push(kataru::GLOBAL.to_string());
                for (character, _character_data) in &section.config.characters {
                    characters.push(character.to_string());
                }
                for (passage_name, _passage) in &section.passages {
                    passages.push(passage_name.to_string());
                }
                for (command_name, params) in &section.config.commands {
                    commands.insert(command_name.to_string(), params.clone());
                }
            } else {
                namespaces.push(namespace.to_string());
                for (character, _character_data) in &section.config.characters {
                    characters.push(format!("{}:{}", namespace, character));
                }
                for (passage_name, _passage) in &section.passages {
                    passages.push(format!("{}:{}", namespace, passage_name));
                }
                for (command_name, params) in &section.config.commands {
                    commands.insert(format!("{}:{}", namespace, command_name), params.clone());
                }
            }
        }

        namespaces.sort();
        passages.sort();
        characters.sort();
        Self {
            namespaces,
            passages,
            characters,
            commands,
        }
    }
}

/// Using the already loaded story, generate constants;
pub fn try_codegen_consts(path: &PathBuf, story: &Story) -> Result<()> {
    let consts = StoryConsts::new(story);
    write_consts_file(
        &path.join("namespaces.gd"),
        fill_consts_template(consts.namespaces),
    )?;
    write_consts_file(
        &path.join("characters.gd"),
        fill_consts_template(consts.characters),
    )?;
    write_consts_file(
        &path.join("passages.gd"),
        fill_consts_template(consts.passages),
    )?;
    write_consts_file(
        &path.join("commands.gd"),
        fill_cmd_consts_template(consts.commands),
    )?;
    Ok(())
}

/// Convert a kataru identifier to a Godot varname.
fn get_varname(name: &str) -> String {
    if name == "global" {
        "Global".to_string()
    } else {
        name.replace(r"$character.", "character_").replace(":", "_")
    }
}

// Write a definition statement for the given value.
fn format_vardef(value: &str) -> String {
    format!("const {} = \"{}\"", get_varname(value.as_ref()), value)
}

fn format_params(param: &str) -> String {
    format!("params.{param}")
}

fn format_adapter(value: &str, params: &Option<Params>) -> String {
    let param_strings: Vec<String> = match params {
        Some(params) => params
            .iter()
            .map(|(param, _value)| format_params(param))
            .collect(),
        None => Vec::new(),
    };
    format!(
        "{funcname}: func(f: Callable, params: Dictionary): f.call({params})",
        funcname = get_varname(value),
        params = param_strings.join(",")
    )
}

fn fill_consts_template(values: Vec<String>) -> String {
    let def_separator = "\n";
    let list_separator = ",\n    ";
    let csv_separator = ",";

    let defs: Vec<String> = values.iter().map(|value| format_vardef(value)).collect();
    let vars: Vec<String> = values.iter().map(|value| get_varname(value)).collect();
    format!(
        r###"# DO NOT EDIT.
# This file was autogenerated by Kataru based on your story.
{defs}

const NAMES: Array[String] = [
    {vars}
]

# Returns the property for usage in the editor.
static func property(property_name: String) -> Dictionary:
	return {{
		"name": property_name,
		"type": TYPE_STRING,
		"usage": PROPERTY_USAGE_DEFAULT,
		"hint": PROPERTY_HINT_ENUM,
		"hint_string": "{csv}"
	}}
"###,
        defs = defs.join(def_separator),
        vars = vars.join(list_separator),
        csv = values.join(csv_separator)
    )
}

fn fill_cmd_consts_template(values: Map<String, Option<Params>>) -> String {
    let def_separator = "\n";
    let list_separator = ",\n    ";

    let defs: Vec<String> = values
        .iter()
        .map(|(value, _params)| format_vardef(value))
        .collect();
    let adapters: Vec<String> = values
        .iter()
        .map(|(value, params)| format_adapter(value, params))
        .collect();
    format!(
        r###"# DO NOT EDIT.
# This file was autogenerated by Kataru based on your story.
{defs}

# Adapters.
var adapters: Dictionary = {{
    {adapters}
}}

var registry: Dictionary = {{}}

func call_command(cmd_name: String, normalized_name: String, params: String):
	self.adapters[normalized_name].call(self.registry[cmd_name], JSON.parse_string(params))

"###,
        defs = defs.join(def_separator),
        adapters = adapters.join(list_separator)
    )
}

fn write_consts_file(path: &PathBuf, source: String) -> Result<()> {
    match fs::read_to_string(path) {
        Ok(old_source) => {
            if source == old_source {
                return Ok(());
            }
        }
        Err(_) => (),
    };
    if let Err(err) = fs::write(path, &source) {
        return Err(error!(
            "Error writing generated file to '{}': {}",
            path.display(),
            err
        ));
    }
    Ok(())
}
